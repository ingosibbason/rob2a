#pragma config(Sensor, in1,    lightSensor,    sensorReflection)
#pragma config(Sensor, in3,    lineFollowerCenter, sensorLineFollower)
#pragma config(Sensor, in4,    lineFollowerLeft, sensorLineFollower)
#pragma config(Sensor, in5,    lineFollowerRight, sensorLineFollower)
#pragma config(Sensor, in6,    gyroSensor,     sensorGyro)
#pragma config(Sensor, in8,    potentiometer,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  touchSensor,    sensorTouch)
#pragma config(Sensor, dgtl6,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl8,  ,               sensorDigitalIn)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           leftMotor,     tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port4,           armMotor,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           clawMotor,     tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float rotations = 360.0;
task EmergencyBrake()
{
	int i;
	while (true)
	{
		if (vexRT[Btn8R] !=0)
		{
			for (i=0; i<3; i++)
			{
				motor[rightMotor] = 0;
				motor[leftMotor]  = 0;
			}
			StopAllTasks();
		}
		wait1Msec(20);
	}
	return;
}
void followLineUntilClose()
{
	int threshold = 2511;      /* found by taking a reading on both DARK and LIGHT    */
	while(SensorValue(sonarSensor) > 13  || SensorValue(sonarSensor) == -1)		// Loop while robot's Ultrasonic sensor is further than 20 inches away from an object
	{

    // RIGHT sensor sees dark:
    if(SensorValue(lineFollowerRight) > threshold)
    {
      // counter-steer right:
      motor[leftMotor]  = 63;
      motor[rightMotor] = 0;
    }
    // CENTER sensor sees dark:
    if(SensorValue(lineFollowerCenter) > threshold)
    {
      // go straight
      motor[leftMotor]  = 63;
      motor[rightMotor] = 63;
    }
    // LEFT sensor sees dark:
    if(SensorValue(lineFollowerLeft) > threshold)
    {
      // counter-steer left:
      motor[leftMotor]  = 0;
      motor[rightMotor] = 63;
    }

	}
	motor[leftMotor]  = 0;
  motor[rightMotor] = 0;
}
void Turn(float r)
{
  SensorValue[rightEncoder] = 0;    /* Clear the encoders for    */
  SensorValue[leftEncoder]  = 0;    /* consistancy and accuracy. */

  // While the encoders have not yet met their goal: (left is compared negativly since it will in reverse)
  while(SensorValue[rightEncoder] < (r * rotations) && SensorValue[leftEncoder] > (-1 * r * rotations))
  {
    motor[rightMotor] = 63;         // Run the right motor forward at half speed
    motor[leftMotor]  = -63;        // Run the left motor backward at half speed
  }
  motor[rightMotor] = 0;            /* Stop both motors!  This is important so that each function          */
  motor[leftMotor]  = 0;            /* can act independantly as a "chunk" of code, without any loose ends. */
}

void armStart()
{
	int potentStart = 600;
	if(SensorValue(potentiometer)> potentStart)
	{
		while(SensorValue(potentiometer) > potentStart){
			motor[armMotor] = 35;
		}
		motor[armMotor] = 0;
	}
	else
	{
		while(SensorValue(potentiometer) < potentStart){
			motor[armMotor] = -35;
		}
		motor[armMotor] = 0;
	}

}

void getItem()
{
	int potentStart = 220;
	motor[leftMotor]  = 0;
  motor[rightMotor] = 0;
	if(SensorValue(potentiometer)> potentStart)
	{
		while(SensorValue(potentiometer) > potentStart){
			motor[armMotor] = 30;
		}
		motor[armMotor] = 0;
	}
	else
	{
		while(SensorValue(potentiometer) < potentStart){
			motor[armMotor] = -30;
		}
		motor[armMotor] = 0;
	}
}
void openClaw()
{
	motor[clawMotor] = -35;
	wait10Msec(10);
}
void closeClaw()
{
	motor[clawMotor] = 35;
	wait10Msec(5);
}

task main()
{
  wait1Msec(2000);          // The program waits for 2000 milliseconds before continuing.

  StartTask(EmergencyBrake);

  armStart();
  //getItem();
  openClaw();

	followLineUntilClose();

	//motor[leftMotor]  = 31;
  //motor[rightMotor] = 31;
	getItem();
  wait10Msec(9);
	closeClaw();
	wait10Msec(30);
	//motor[leftMotor]  = 20;
  //motor[rightMotor] = 20;
  wait10Msec(1);
	closeClaw();
	wait10Msec(10);
	armStart();
	wait10Msec(10);

	Turn(1.7);

	followLineUntilClose();


	motor[leftMotor]  = 31;
  motor[rightMotor] = 31;
  wait10Msec(9);
  motor[leftMotor]  = 0;
  motor[rightMotor] = 0;
	wait10Msec(20);
	getItem();
	openClaw();
	wait10Msec(20);
	armStart();



}
