#pragma config(Sensor, in1,    lightSensor,    sensorReflection)
#pragma config(Sensor, in3,    lineFollowerCenter, sensorLineFollower)
#pragma config(Sensor, in4,    lineFollowerLeft, sensorLineFollower)
#pragma config(Sensor, in5,    lineFollowerRight, sensorLineFollower)
#pragma config(Sensor, in6,    gyroSensor,     sensorGyro)
#pragma config(Sensor, in7,    colorSensor,    sensorLineFollower)
#pragma config(Sensor, in8,    potentiometer,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  touchSensor,    sensorTouch)
#pragma config(Sensor, dgtl6,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl8,  ,               sensorDigitalIn)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           leftMotor,     tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port4,           armMotor,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           clawMotor,     tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float rotations = 360;
int threshold = 2711;      /* found by taking a reading on both DARK and LIGHT    */
bool black = false;
bool blackItemSecured = false;


task EmergencyBrake()
{
	int i;
	while (true)
	{
		if (vexRT[Btn8R] !=0)
		{
			for (i=0; i<3; i++)
			{
				motor[rightMotor] = 0;
				motor[leftMotor]  = 0;
			}
			StopAllTasks();
		}
		wait1Msec(20);
	}
	return;
}
void followLineUntilClose()
{

	while(SensorValue(sonarSensor) > 15  || SensorValue(sonarSensor) == -1)		// Loop while robot's Ultrasonic sensor is further than 15 inches away from an object
	{

    // RIGHT sensor sees dark:
    if(SensorValue(lineFollowerRight) > threshold)
    {
      // counter-steer right:
      motor[leftMotor]  = 63;
      motor[rightMotor] = 0;
    }
    // CENTER sensor sees dark:
    if(SensorValue(lineFollowerCenter) > threshold)
    {
      // go straight
      motor[leftMotor]  = 63;
      motor[rightMotor] = 63;
    }
    // LEFT sensor sees dark:
    if(SensorValue(lineFollowerLeft) > threshold)
    {
      // counter-steer left:
      motor[leftMotor]  = 0;
      motor[rightMotor] = 63;
    }

	}
	motor[leftMotor]  = 0;
  motor[rightMotor] = 0;
}
void Turn(float r)
{
  SensorValue[rightEncoder] = 0;    /* Clear the encoders for    */
  SensorValue[leftEncoder]  = 0;    /* consistancy and accuracy. */

  // While the encoders have not yet met their goal: (left is compared negativly since it will in reverse)
  while(SensorValue[rightEncoder] < (r * rotations) && SensorValue[leftEncoder] > (-1 * r * rotations))
  {
    motor[rightMotor] = 63;         // Run the right motor forward at half speed
    motor[leftMotor]  = -63;        // Run the left motor backward at half speed
  }
  motor[rightMotor] = 0;            /* Stop both motors!  This is important so that each function          */
  motor[leftMotor]  = 0;            /* can act independantly as a "chunk" of code, without any loose ends. */
}
void TurnBack(float r)
{
  SensorValue[rightEncoder] = 0;    /* Clear the encoders for    */
  SensorValue[leftEncoder]  = 0;    /* consistancy and accuracy. */

  // While the encoders have not yet met their goal: (left is compared negativly since it will in reverse)
  while(SensorValue[rightEncoder] < (r * rotations) && SensorValue[leftEncoder] > (-1 * r * rotations))
  {
    motor[rightMotor] = -63;         // Run the right motor forward at half speed
    motor[leftMotor]  = 63;        // Run the left motor backward at half speed
  }
  motor[rightMotor] = 0;            /* Stop both motors!  This is important so that each function          */
  motor[leftMotor]  = 0;            /* can act independantly as a "chunk" of code, without any loose ends. */
}

void armStart()
{
	int potentStart = 600;
	if(SensorValue(potentiometer)> potentStart)
	{
		while(SensorValue(potentiometer) > potentStart){
			motor[armMotor] = 35;
		}
		motor[armMotor] = 0;
	}
	else
	{
		while(SensorValue(potentiometer) < potentStart){
			motor[armMotor] = -35;
		}
		motor[armMotor] = 0;
	}

}

void getItem()
{
	int potentStart = 220;
	motor[leftMotor]  = 0;
  motor[rightMotor] = 0;
	if(SensorValue(potentiometer)> potentStart)
	{
		while(SensorValue(potentiometer) > potentStart){
			motor[armMotor] = 40;
		}
		motor[armMotor] = 0;
	}
	else
	{
		while(SensorValue(potentiometer) < potentStart){
			motor[armMotor] = -40;
		}
		motor[armMotor] = 0;
	}
}
void openClaw()
{
	motor[clawMotor] = -35;
	wait10Msec(10);
}
void closeClaw()
{
	motor[clawMotor] = 35;
	wait10Msec(5);
}

void blackItemsMatter()
{
  	//move white item
  	if(SensorValue(colorSensor) < threshold)//if object is not black, move it
  	{
  		motor[leftMotor]  = -31; //Move away from white object
  		motor[rightMotor] = -31;
  		wait10Msec(40);
  		Turn(1.8); //Turn around
  		motor[leftMotor]  = 31;  //Move forward
  		motor[rightMotor] = 31;
  		wait10Msec(40);
			getItem(); //Put arm down
  		wait10Msec(40);
			openClaw(); //Close claw and drop Black item
			wait10Msec(40);
			armStart();  //Put arm u
			motor[leftMotor]  = -31; //Move away from black item
  		motor[rightMotor] = -31;
  		wait10Msec(40);
			turn(1.8);
			motor[leftMotor]  = 31; //Move to white object
  		motor[rightMotor] = 31;
  		wait10Msec(40);
  		getItem(); //Put arm down
  		closeClaw(); //Close claw and pick up white object
  		wait10Msec(40);
  		armStart(); // Put arm up
  		wait10Msec(40);
  		turn(0.9); //turn 90 degrees
  		wait10Msec(20);
  		//motor[leftMotor]  = 31; //move away from track
  		//motor[rightMotor] = 31;
  		wait10Msec(40);
  		getItem(); //Put arm down
  		wait10Msec(40);
  		openClaw(); //Opem claw and put away white object
  		wait10Msec(40);
  		armStart(); //put arm up
  		//motor[leftMotor]  = -31; //move back to track
  		//motor[rightMotor] = -31;
  		wait10Msec(40);
  		Turn(1.8);
  		followLineUntilClose(); //Move to black object
  		motor[leftMotor]  = 31; //move closer to black object
  		motor[rightMotor] = 31;
  		wait10Msec(40);
  		getItem(); //Put arm down
  		closeClaw(); //Close claw and pick up white object
  		wait10Msec(40);
  		armStart(); //put arm up
  		Turn(1.8) //Turn around


  	}
  	else
  	{
  		//Return black object
  		motor[leftMotor]  = 31; //Move closer to box
 			motor[rightMotor] = 31;
  		wait10Msec(40);
  		motor[leftMotor]  = 0; //Stop motors
  		motor[rightMotor] = 0;
			wait10Msec(20);
			getItem();
			wait10Msec(20);
			openClaw();
			wait10Msec(20);
			armStart();
			black = true;
		}


}

void isItemBlack()
{

	//int threshold = 2511;      /* found by taking a reading on both DARK and LIGHT    */
	if(blackItemSecured == true)
	{
		blackItemsMatter();
	}
	else if(SensorValue(colorSensor) < threshold)//if object is not black, move it
  {
    //get to reach distance for item
    motor[leftMotor]  = -31;
  	motor[rightMotor] = -31;
  	wait10Msec(40);

  	//pick up item
    getItem();
  	wait10Msec(40);
		closeClaw();
		wait10Msec(40);
		armStart();

		//turn around and move item
		Turn(0.9);
		//motor[leftMotor]  = 31;
  	//motor[rightMotor] = 31;
  	//wait10Msec(40);

  	//Drop item
  	getItem();
		openClaw();
		wait10Msec(40);
		armStart();
		wait10Msec(10);

		//go back to line
		//motor[leftMotor]  = -31;
  	//motor[rightMotor] = -31;
  	wait10Msec(40);
  	TurnBack(0.7);
   }
   else
   {
    	black = true;
   }
}

task main()
{
  wait1Msec(2000);          // The program waits for 2000 milliseconds before continuing.

  StartTask(EmergencyBrake);



  armStart(); //Moves arm up
  openClaw(); //Opens claw

  while(black == false)
  {
  	followLineUntilClose(); //Follows line until close to object
 		motor[leftMotor]  = 31;
  	motor[rightMotor] = 31;
  	wait10Msec(40); //Move a bit closer to ocject
  	isItemBlack(); //Checks if item is black
	}
	wait10Msec(13);
	black = false;
	motor[leftMotor]  = -31; //Get to reach distance of object
  motor[rightMotor] = -31;
  wait10Msec(60);
	getItem();
  wait10Msec(40);
	closeClaw();
	wait10Msec(40);
	armStart();

	blackItemSecured = true;
	Turn(1.8);


	while(black == false)
  {
  	followLineUntilClose();
 		motor[leftMotor]  = 31;
  	motor[rightMotor] = 31;
  	wait10Msec(40);
  	isItemBlack();
	}













	//followLineUntilClose();
	//motor[leftMotor]  = 31;
  //motor[rightMotor] = 31;
	//getItem();
  //wait10Msec(9);
	//closeClaw();
	//wait10Msec(30);
	//motor[leftMotor]  = 20;
  //motor[rightMotor] = 20;
  //wait10Msec(1);
	//closeClaw();
	//wait10Msec(10);
	//armStart();
	//wait10Msec(10);
	//Turn(1.7);
	//followLineUntilClose();
	//motor[leftMotor]  = 31;
  //motor[rightMotor] = 31;
  //wait10Msec(9);
  //motor[leftMotor]  = 0;
  //motor[rightMotor] = 0;
	//wait10Msec(20);
	//getItem();
	//openClaw();
	//wait10Msec(20);
	//armStart();



}
